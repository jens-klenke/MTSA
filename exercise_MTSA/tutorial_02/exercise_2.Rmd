---
title: 'Multivariate Time Series Analysis'
author: 'Dr. Yannick Hoga'
author2: 'Thilo Reinschl√ºssel'
subtitle: 'Exercise Sheet 2'
semester: "Winter Term 2019/2020"
output:
  pdf_document:
    keep_tex: yes
    template: ../template.tex
    fig_caption: yes
    citation_package: biblatex
    number_sections: true
toc: true
lot: true
lof: true
graphics: true
linkcolor: black
urlcolor: black
citecolor: black
colorlinks: true
font: Times New Roman
fontsize: 12pt
geometry: lmargin = 2cm, rmargin = 2.5cm, tmargin = 2cm, bmargin = 2.5cm
classoption: a4paper
---

```{r , include=FALSE}
Sys.setlocale(locale = "English_United States.1252") ## English US Windows
knitr::opts_chunk$set(echo = TRUE)

source(here::here("packages/packages.R"))
```

# Exercise 1: Moments and Simulation of a VAR(1) Process

Take the model from Example 2.4 on Slide 2-6:

\begin{itemize}
  \item[a)] Derive a formula to obtain the population cross-covariance matrices for the lags 1 to 10 and compute them using R.
  \item[] \textit{Hint: A glance at the slides and a loop might save you some time.}
  \item[b)] Based on your results, compute the cross-correlation matrices.
\end{itemize}

_Solution:_ \

\begin{align*}
  z_t & = \phi_1 z_{t-1} + a_t\\
  \\
  \Gamma_0 & = \phi_1  \ \Gamma_0 \ \phi_1^{'} + \Sigma_a\\
  \Leftrightarrow \vec(\Gamma_0) &= (\phi_1 \otimes \phi_1) \cdot \vec(\Gamma_0) + \vec(\Sigma_a) \\
  \Leftrightarrow \vec(\Gamma_0) &= (I_{K^2} - \phi_1 \otimes \phi_1) \cdot \vec(\Sigma_a) \\
 \Rrightarrow \Gamma_1 & = \phi_1 \Gamma_0\\
 \Rrightarrow \Gamma_l & = \phi_{l-1} \Gamma_{l-1} = \phi_1^{l} \Gamma_0\\
\end{align*}


```{r}
# First define parameters/coefficients:
Phi <- matrix(data = c(0.2, -0.6, 0.3, 1.1), 
              byrow = FALSE, nrow = 2) # VAR coefficients
k <- ncol(Phi)
Sigma_a <- matrix(data = c(1, 0.8, 0.8, 2.0), 
                  byrow = FALSE, nrow = 2) # innovations' covariances

Phi_kron <- kronecker(X = Phi, Y = Phi) # kronecker product
# Phi %x% Phi # alternative command

Ident <- diag(ncol(Phi_kron)) 
# identity matrix with the same dimensions as Phi_kron

Gamma0.vec <- solve(Ident - Phi_kron) %*% c(Sigma_a) 
# c() works like the "vec" operator

Gamma0.mat <- matrix(data = Gamma0.vec, nrow = 2, byrow = FALSE)
```

The $\Gamma_0$ matrix is than:  

```{r, echo = FALSE}
Gamma0.mat
```

To derive the $\Gamma_1$ matrix, we can apply the following formula: 

\begin{align*}
  \Gamma_1 & = \phi_1 \Gamma_0\\
\end{align*}

```{r}
Gamma1.mat <- Phi %*% Gamma0.mat
```

$\Gamma_1$ is than: 

```{r, echo = FALSE}
Gamma1.mat
```

To derive all desired $l^{Th}$ laged covariance matrices we can use the general equation and program a loop over all desired lags:

\begin{align*}
  \Rrightarrow \Gamma_l & = \phi_{l-1} \Gamma_{l-1} = \phi_1^{l} \Gamma_0\\
\end{align*}

To derive the correlation matrices $\rho_l$ we devide the covariances by the standard deviations:

\begin{align*}
  \rho_l = 
  \begin{pmatrix}
    \dfrac{\Cov(x_t , x_{t-l})}{\sqrt{\Var(x_t) \cdot \Var(x_{t- l})}} &
    \dfrac{cov(x_t , y_{t-l})}{\sqrt{\Var(x_t) \cdot \Var(y_{t- l})}}\\
    \dfrac{cov(y_t , x_{t-l})}{\sqrt{\Var(y_t) \cdot \Var(x_{t- l})}} &
    \dfrac{cov(y_t , y_{t-l})}{\sqrt{\Var(y_t) \cdot \Var(y_{t- l})}}
  \end{pmatrix}\\
\end{align*}

```{r}
# compute further (lagged) cross-covariance-functions
# preparing the variables to store the matrices into: covariance
ccovf.list <- list() 
# """ : correlation
ccorf.list <- list() 

# obtaining standard deviations for the single variables (parts of z) 
#and putting them in a diagonal matrix
D.inv <- solve(sqrt(Gamma0.mat * diag(ncol(Phi)))) 
for (i in 1:10){
  ccovf.list[[i]] <- Phi%^%i %*% Gamma0.mat
  ccorf.list[[i]] <- D.inv %*% ccovf.list[[i]] %*% D.inv
}
ccovf.list # cross lagged covariances
ccorf.list # cross lagged correlations
```

\begin{itemize}
  \item[c)] Draw a corresponding innovation sequence at for 300 periods from a (multivariate) Gaussian distribution and simulate the given VAR(1) process without any further built-in functions
  \item[] \textit{Hint: 'mvrnorm' and 'for' are still allowed}
\end{itemize}

_Solution:_ \

\begin{enumerate}
  \item Set $T$ (in code $N$)
  \item Draw $\left\{ a_1, \ldots , a_T \right\} \sim \left[ \mu , \Sigma_a \right]$
  \item Set $z_0 = \mathbb{E} \left( z_t\right)$
  \item $z_1 = \phi_1 z_0 + a_1$
  \item Repeat Sep 4 $(T - 1)$ times
  \item (Discard first few observations to minimise effects of $z_0$ on the results)
  \begin{itemize}
    \item[$\Rightarrow$] \textit{Note} that it is generally advised to discard the first few observations to eliminate the influence of the arbitrary starting point! In our case we skipped this step to keep things short and clear.
  \end{itemize}
\end{enumerate}


```{r}
# i) Set sample size and further coefficients
N <- 300
# ii) The Basis: Innovations
set.seed(2^9-1) # for replication: the 'random' numbers drawn 
# up from this point will always be the same (given you use 
# the same command to draw them....)
a <- mvrnorm(n = N, mu = c(0,0), Sigma = Sigma_a)
# iii) Writing a function to generate 'z' realisations from 'a' using Phi
var1gen <- function(coef.mat, z.lag, innovation){
  z.current <- coef.mat %*% z.lag + innovation 
  # z_(t) = phi * z_(t-1) + a_(t)
  return(z.current)
}
# iv) Prepare variable for 'z'
z <- ts(data = matrix(data = NA, nrow = (N), ncol = k)
        ,start = 1, names = c("z_1", "z_2"))
# v) Set starting values for z (at mean + innovation)
z[1,] <- c(0,0) + a[1,]
# vi) Generate z repeatedly and store it
for (i in 2:(N)){
  z[i,] <- var1gen(coef.mat = Phi, z.lag = z[(i-1),], innovation = a[i,])
}
```

\begin{itemize}
  \item[d)] Plot the multivariate time series you have just created. Does it look stationary?
\end{itemize}

```{r}
# The ordinary 'plot' command works because 'z' is already 
# a 'ts'-class object (among other classes) and NOT a data frame!
plot(z)
```

At least it looks stable hence we cannot rule out stationarity. 


\begin{itemize}
  \item[e)] Estimate the sample cross-covariance and cross-correlation matrices. Compare these with the population moment matrices from task a)
\end{itemize}

\begin{align*}
  \widehat{\Gamma_0} & = \tilde{z}_T^{'} \tilde{z}_{T-1} \cdot (T - 1)^{-1} \\
  \tilde{z}_T^{'} & = z_T - \widehat{\mu}_z\\
  Z & \ \text{is a} \ T \times 2 \ \text{matrix}\\
  z_t &\  \text{is a} \ 2 \times 1 \ \text{vector}\\
  z_t & := 
  \begin{pmatrix}
    x_t \\
    y_t
  \end{pmatrix} \; \leftarrow \text{variables}\\
  Z_t & := 
  \begin{pmatrix}
    X_{t} & Y_{t} \\
    X_{t-1} & Y_{t-1} \\
    X_{t-2} & Y_{t-2} \\
    \vdots & \vdots \\
    X_{t-t} & Y_{t-t} \\
  \end{pmatrix} \; \leftarrow \text{sample data}\\
\end{align*}

\begin{align*}
  \widehat{\Cov(x_t, y_{t-1})}
\end{align*}









